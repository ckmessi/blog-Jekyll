---
layout: post
title:  "Manacher算法学习"
date:   2015-12-08 22:32:00
categories: LeetCode
tags: [LeetCode, Algorithm, String]
---

Manacher算法是在O(n)时间复杂度内，在给定字符串中找到最大长度回文子串的算法。

##一、预处理部分

由于原始字符串的长度可能是奇数或偶数，处理起来比较麻烦，Manacher算法首先通过一个巧妙的变换将其统一。  
变化方式如下：在每个字符两侧都插入特殊符号"#"，比如"abba"变成"#a#b#b#a#a#"，"aba"变成"#a#b#a#"，假设原字符串长度为n，变换时共插入了n+1个符号"#"，最终字符串长度为2n+1，这样肯定保证变换后的字符串是奇数长度；另外为了处理边界问题，在字符串头部加入特殊字符"$"。  
比如初始字符串为S = "12212321"，经过变化后变成了S' = "$#1#2#2#1#2#3#2#1#"  

另外，使用与变换后字符串长度相等的数组元素P[i]记录以S[i]为中心的最长回文子串向左/右扩张的长度（包括S[i]自身），比如：  

> S    # 1 # 2 # 2 # 1 # 2 # 3 # 2 # 1 #  
> P    1 2 1 2 5 2 1 4 1 2 1 6 1 2 1 2 1  

这里可以看出，P[i]-1正好是以当前位置为主心，原字符串中回文串的长度。

##二、算法核心不等式

算法使用两个辅助变量id和mx（这两个变量的命名实在是不好！），其中id表示最大回文子串中心的位置，mx的值为P[id]+id，即最大回文子串的右边界。  
（这里语义上有点偏差，需要注意的是id和mx记录的，并不是全局最长子串的中心和边界，而是先确认当前最右边的边界，设置为mx，然后根据mx确定id的位置，本质上是尽可能多的利用S[id]所能庇护到的区间，尽可能向右。在这种情况下，单纯遍历一次并不能确定最大子串中心位置，并不一定是id，在结束之后，还需要再遍历一次，取P[i]最大值的i作为最长回文子串的位置。）  

这里浅显的理解可以是这样的，我们将遍历整个字符串每个字符S[i]，查找以当前字符为主心的最长回文子串长度，如果目前以S[i]为中心的回文子串是最长的，则将当前位置i设置为id；而mx的值记录的是P[id]+id的值，即当前位置id再向前延伸P[id]长度后，所能达到的位置mx，由于S[id~mx]是回文子串的右半侧，可以有一些性质供算法使用。  
下面将详细说明。  

关键的条件不等式是：当mx > i时，P[i] >= min(P[2*id - i], mx - i)  
这个不等式看起来比较难懂，我们可以先根据条件及不等式的左侧来思考一下它的含义。  
对于条件mx > i，由于之后在求解过程中，是逐个遍历字符串的元素S[i]的，因此在考虑当前字符S[i]时，id的值及mx的值应该是确定的，且已知id < i，但mx与i的关系未知。如果mx > i，说明此前以id为主心的回文串，覆盖了当前字符S[i]的位置i。  
对于不等式左侧P[i]，表示的是以字符S[i]为中心的回文子串最大长度，是我们要求的；朴素的思想是由s[i]向两侧延伸，比较S[i+1]与S[i-1]，S[i+2]与S[i-2]，...的关系，直到不相等为止；Manacher算法的核心思想就在于（类似于KMP算法），利用已知信息，直接先获得一个肯定正确的最小解，然后再不断延伸。  

我们来看这个不等式为什么会成立。  
对于不等式中的两项，P[2*id-i]表示的是以位置j=2*id-1为中心的回文子串长度。S[j]是S[i]关于S[id]的对称点（因为j+i=2*id => id-j = i-id）；而mx-i表示的是从位置i~mx的长度。  
如果P[2*id-i]< mx - i，说明以S[j]为中心的回文串的长度，向左没有延伸到mx的对称点以左（参照下图1），说明S[j]的回文串包含在S[id]的回文串内。根据S[id]所提供的对称性，以S[i]为中心的字符串性质与以S[j]为中心的字符串性质是相同的，因此有P[i] = P[j] = P[2*id - i]。  
如果P[2*id-i] > mx - i，说明以S[j]为中心的回文串长度已经向左超出了mx的对称点以左（参照下图2），此时由于S[id]所提供的对称性只局限到mx对称点位置，mx对称点以左的情况我们不知道，不敢妄言，因此只能说P[i]的长度至少是mx-i（图中绿色方框位置），即P[i] >= mx - i。在算法解决过程中，我们这里令P[i] = mx - i，此后再一个一个比较。  

（图片引自博客：http://www.cnblogs.com/biyeymyhjob/archive/2012/10/04/2711527.html）

当前不等式的含义已经清楚了，对于不满足条件的mx <= i，的情况由于我们无法利用S[id]所提供的对称性，因此不能下定论，只能一个一个匹配，初始设置P[i] = 1，然后匹配即可。  

##三、算法流程描述

我们可以根据上述分析，写出算法流程描述如下：


```  

for i = 1 ~ n do   
    // 对S[i]求最大子串长度   
    （Manacher算法的关键在这里）        
    if mx > i   
        P[i] = min(P[2 * id - i], mx - i)        // 这一步，利用已有S[id]的信息，减少了很多很多工作   
    // 假设不使用Manacher算法，普通的匹配方式是以下的，时间复杂度为O(n^2)
    P[i] = 1
    while(s[i-P[i]] == s[i+P[i]])    // 由于预处理s[0]为全局唯一的字符，必导致等式不成立，会退出循环
        P[i]++
    // 判断是否是最大值，登记信息等
    if P[i] > mx - id
        id = i
        mx = P[i] + i
    end  
end  

```

这样思路就挺清楚的了。  
最后遍历一次，可以得到使P[i]最大的下标i，标识了全局最长回文子串的中心位置，而P[i] - 1 是全局最长回文子串的长度。  

##四、后续处理
根据Manacher算法，已经可以得到全局最长回文子串的长度，以及子串的中心位置。  
关于如何获取到原回文字符串的问题。  
（唉妈呀累死我了，以后再整理吧。）  


```
// 现在最长子串的位置是pos，长度为P[pos]
// 根据预处理时的位置计算，原来字符串i的当前位置为i*2+2，由pos=i*2+2可算出i = (pos-2)/2
// 需要注意的是，如果pos奇数，说明中心字符是'#'，该中心在原来字符串的位置是两字符之间，最终回文长度为偶数；如果是偶数，中心就是原字符串的某个字符，最终回文是以当前字符为中心的长度。
// 对于P[pos]，根据性质，如果pos为奇数，说明当前字符是'#'，此时P[pos]必是奇数（因为自身是1，如果向外扩展1个，再向外两侧都是'#'可再扩展，肯定是奇数。）；如果pos为偶数，同理P[pos]为偶数
// 因此可以知道，当pos为奇数时，以pos为中心回文串，左侧起始位置为 pos - (P[pos] - 2)，右侧为pos + (P[pos] - 2)；当pos为偶数是，左侧起始位置为pos - (P[pos] - 2) 右侧为pos + (P[pos] + 2)
// 根据上述算法，位置是偶数，必能还原到原始位置
```


我们可以撰写manacher算法如下：

**Java Code**
{% highlight Java %}
public String longestPalindrome(String s){
    // preprocess
    StringBuffer strBuff = new StringBuffer();
    strBuff.append("$#");
    for(int i = 0; i < s.length(); i++){
        strBuff.append(s.charAt(i));
        strBuff.append("#");
    }
    String str = strBuff.toString();
    int len = str.length();
    int[] P = new int[len + 1];
    P[0] = 0;
        
    int id = 0;
    int mx = 0;
    for(int i = 1; i < str.length(); i++){
        if(mx > i){
            P[i] = Math.min(P[2 * id - i], mx - i);
        }
        else{
            P[i] = 1;
        }
        // 对于 $#1#，i=2的时候会越界
        while((i + P[i] < str.length()) && (str.charAt(i - P[i]) == str.charAt(i + P[i]))){
            P[i]++;
        }
        if(P[i] + i > mx){
            id = i;
            mx = P[i] + i;
        }
    }
    // 获取位置
    int pos = 0;
    int maxLength = 0;
    for(int i = 0; i < P.length; i++){
        if(P[i] > maxLength){
            maxLength = P[i];
            pos = i;
        }
    }
        
    // 现在最长子串的位置是pos，长度为P[pos]
    // 根据预处理时的位置计算，原来字符串i的当前位置为i*2+2，由pos=i*2+2可算出i = (pos-2)/2
    // 需要注意的是，如果pos奇数，说明中心字符是'#'，该中心在原来字符串的位置是两字符之间，最终回文长度为偶数；如果是偶数，中心就是原字符串的某个字符，最终回文是以当前字符为中心的长度。
    // 对于P[pos]，根据性质，如果pos为奇数，说明当前字符是'#'，此时P[pos]必是奇数（因为自身是1，如果向外扩展1个，再向外两侧都是'#'可再扩展，肯定是奇数。）；如果pos为偶数，同理P[pos]为偶数
    // 因此可以知道，当pos为奇数时，以pos为中心回文串，左侧起始位置为 pos - (P[pos] - 2)，右侧为pos + (P[pos] - 2)；当pos为偶数是，左侧起始位置为pos - (P[pos] - 2) 右侧为pos + (P[pos] + 2)
    // 根据上述算法，位置是偶数，必能还原到原始位置
        
    int left = pos - (P[pos] - 2);
    int right = pos + (P[pos] - 2);
        
    left = (left - 2) / 2;
    right = (right - 2)  / 2;
        
    String x = s.substring(left, right + 1);
    return x;
        
}

{% endhighlight%}




