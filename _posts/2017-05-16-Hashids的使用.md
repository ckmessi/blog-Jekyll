---
layout: post
title:  "Hashids的使用"
date:   2017-05-16 12:06:00
categories: Others  
tags: [整理]
---
# Hashids的使用

### 1. Hashids的应用场景

最近遇到一个问题，要求不把数据库保存的自增id暴露在公开的url中，防止不怀好意的用户进行撞库、爬取数据等攻击。于是需要将简单的自增ID转换为唯一标识的字符串序列，通过字符串去查找内容，这样用户无法通过修改ID号的方式遍历所有数据。

应用场景还是很明确的，我想起了两件事。
一是在网易游戏实习时，为了不让当天的维护公告内容被用户事先得知，公告url的命名不能太有规则，不能使用户“猜到”当天的链接命名。   
二是校招去搜狐面试的时候，曾被问到的一个问题就是，如何为id生成唯一的随机字符串，当时答得就不是特别好。   


最初方案是想着自己用一个md5函数将id加密，然后保存到数据库中，之后通过这个md5码进行查找即可。后来想想应该会有现成的轮子，不用自己撰写，而且自己撰写有可能有极小的概率无法保证其唯一性。  

后来就发现了这个工具：[Hashids](http://hashids.org/)

它具有多种语言、多种框架的适配方式。

### 2. Hashids在Laravel中的使用

#### 安装

在Laravel项目中使用composer安装：
`$ composer require vinkla/hashids`
在Laravel项目的config/app.php进行如下修改：
`Vinkla\Hashids\HashidsServiceProvider::class`
如果想使用Facade，继续添加一处：
`'Hashids' => Vinkla\Hashids\Facades\Hashids::class`
运行命令，会生成一个`config/hashids.php`文件，在其中可以进行hashids相关的配置
`php artisan vendor:publish`

#### 基本使用方法
```
use Vinkla\Hashids\Facades\Hashids;
$md5_str = Hashids::connection('main')->encode(1234);
$origin_array = Hashids::decode($md5_str);
```
需要注意的是decode方法解析出来是一个数组，需要判断其长度来获取是否有合法的解密结果。

#### 参数配置
在`config/hashids.php`文件中，可以设置盐和长度等内容
```
    'connections' => [

        'main' => [
            'salt' => 'your-salt-string',
            'length' => 10,
        ],

        'alternative' => [
            'salt' => 'your-salt-string',
            'length' => 'your-length-integer',
        ],

    ],
```
其中将length设置为10，则可以保证在ID较小的时候，看起来比较高大上（默认1位数的ID加密出来只有2个字母）。

### 3. Hashids的一些使用策略

在了解Hashids的使用流程后，我就产生了一个疑问，既然它能够实现双向加密解密，我是否还需要在数据库中为其保留加密后的字符串呢？    
通过搜索，发现了Hashids的创建者的[回答](https://laracasts.com/discuss/channels/general-discussion/should-i-store-hashids-in-database-or-decode-them-on-every-request)很有价值。
大概意思是，需要根据实际情况进行判断：
1. 通过Hashids产生的Id是唯一的，不需要进行检查
2. 最小长度参数将会为生成的Id进行补全操作。
3. 关于database vs. on-the-fly的方式对比，在我的项目中通常是使用on-the-fly方式，因为这样比较简单。通常会将一个表的主键id进行加密，因此解密的过程是很快速的。如果为slugs（这里不太懂怎么翻译？）单独创建一列，可能需要为它创建一个索引，这样数据库需要为这个不必要的索引花费更多的管理成本。


### 4. Hashids的原理

在[Hashids](http://hashids.org/)的官网上有一段说明，解析了Hashids是怎么工作的。   
Hashids的工作原理很像将整数转换为十六进制，但有两点不同：
1. 字母表不是16进制，而是62进制（默认）
2. 字母表会通过salt字符串进行随机变换

